# Chapter6 可执行文件的装载与进程

本章介绍ELF文件在Linux下的装载过程。依次介绍进程虚拟地址空间/覆盖装载/页映射/进程虚拟地址空间的分布情况

## 进程虚拟地址空间

每个进程有自己独立的虚拟地址空间，它的大小由CPU位数决定。硬件决定地址空间的最大理论上限。即硬件的寻址空间大小，比如32位平台是4GB，64位是17179869184GB。下文以32位地址空间为主。

32位平台下的4G虚拟空间显然不是程序可以任意使用的，进程只能使用OS分配的地址。如果访问了未经允许的空间，OS会捕获并抛出错误，结束进程。Windows下是 “进程因非法操作需要关闭” ； Linux下则是 “Segmentation fault”。

32位下，Linux的OS空间分配是这样的：

![image-20250202210835008](./Chapter6.assets/image-20250202210835008.png)

现在的很多程序运行需要远大于3G的空间。一种解决方法是换成64位的机器，如果条件不允许，则在后面的PAE中介绍。

### PAE

Intel的Pentinum Pro CPU开始采用了36位物理地址，可以访问64G的物理内存。同时，Intel修改了页映射方式，让新的映射方式可以访问到更多物理内存，这个方式就是PAE（Physical Address Extension）。

对于程序来说，它还是只有32位的虚拟地址空间。OS会提供一个窗口映射的方法，把额外内存映射到进程地址空间中。比如把应用程序中0x10000000～0x20000000这256M的空间作为窗口。如果程序要使用高于4G的物理空间，可以把高于4G的物理空间分割成多个256M的小空间，用到哪个就把哪个的地址映射到这个窗口上。在Windows下这个方法是AWE，在Linux等类UNIX OS中，则使用`mmap()`系统调用实现。

## 装载的方式

根据程序的局部性原理，可以把程序最常用的部分留在内存，其他部分放在磁盘里，这就是动态装入的基本原理。 **覆盖装入（Overlay）** 和 **页映射（Paging）** 是两种典型的动态装载方法。

### 覆盖装入

过时的装载方式，在虚拟内存概念出来之前很常用。由开发人员挖掘内存潜力。使用覆盖管理器（Overlay Manager）来辅助管理。对于两个不会相互调用的模块AB来说，它们可以被这样安排：

![image-20250202213519905](./Chapter6.assets/image-20250202213519905.png)

更复杂一点，程序员需要手工把模块按调用依赖关系组织成树状结构。

![image-20250202213615485](./Chapter6.assets/image-20250202213615485.png)

- 从任何一个模块到根都叫调用路径。当该模块被调用时，整个调用路径上的模块必须都在内存中。
- 禁止跨树间调用。任意一个模块都不允许跨过树状结构调用。

### 页映射

随着虚拟存储机制的出现同步出现的机制。它把内存和所有磁盘数据和指令按页为单位划分， **所有装载和操作的单位就是页**。为了演示，假设在32位机器上有16KB的内存，每个页大小为4096B，那么一共有4个页。

![image-20250202214030762](./Chapter6.assets/image-20250202214030762.png)

假设程序大小为32K，共被分为8个页，编号为P0-P7，运行过程中的页映射关系可能如下：

![image-20250202214212495](./Chapter6.assets/image-20250202214212495.png)

OS根据不同的算法来管理装载过程。Windows和Linux都是这样完成和管理装载的。

## 从操作系统角度看可执行文件装载

